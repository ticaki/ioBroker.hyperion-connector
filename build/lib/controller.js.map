{
  "version": 3,
  "sources": ["../../src/lib/controller.ts"],
  "sourcesContent": ["import { Hyperion } from './hyperion';\nimport { BaseClass, type AdapterClassDefinition } from './library';\nimport { Network } from './network';\nimport type { configOfHyperionInstance, DescriptionType } from './types-d';\n\n/**\n * Hyperion class\n * do all then work here\n */\nexport class Controller extends BaseClass {\n    network: Network;\n    hyperions: Hyperion[] = [];\n    deviceList: configOfHyperionInstance[] = [];\n\n    initLogInterval: ioBroker.Interval | undefined = undefined;\n    /**\n     * constructor\n     *\n     * @param adapter adapter class definition\n     */\n    constructor(adapter: AdapterClassDefinition) {\n        super(adapter, 'Controller');\n        this.network = new Network(this.adapter, 'Network');\n    }\n\n    /**\n     * init\n     * init all devices from config and do a network discovery\n     * give user a log message about the found devices\n     */\n    async init(): Promise<void> {\n        const devices = this.adapter.config.devices;\n        if (devices) {\n            for (const device of devices) {\n                if (device.enabled) {\n                    try {\n                        if (this.hyperions.every(h => h.UDN !== device.UDN)) {\n                            const data: configOfHyperionInstance = {\n                                UDN: device.UDN.replace('uuid:', ''),\n                                name: device.name,\n                                protocol: device.protocol,\n                                ip: device.ip,\n                                port: device.port,\n                                token: '',\n                                enabled: true,\n                            };\n                            this.log.debug(`Init device: ${device.name} from config`);\n                            const hyperion = new Hyperion(this.adapter, data.UDN, data);\n                            this.hyperions.push(hyperion);\n                            await hyperion.init();\n                        }\n                    } catch (error) {\n                        this.log.warn(`Error while init device: ${device.name} - ${String(error)}`);\n                    }\n                }\n            }\n        }\n\n        await this.network.doDiscovery(this.findDevice);\n        this.initLogInterval = this.adapter.setInterval(() => {\n            if (this.hyperions.some(h => h.connectionState === 'pendingAuthorize')) {\n                return;\n            }\n\n            const notConfigured =\n                this.hyperions.filter(\n                    item =>\n                        !(this.adapter.config.devices || [{ UDN: null }]).some(\n                            (c: configOfHyperionInstance) => c.UDN === item.UDN,\n                        ),\n                ) || [];\n\n            const disconnected =\n                this.hyperions.filter(\n                    item => item.connectionState === 'disconnected' || item.connectionState === 'notAuthorize',\n                ) || [];\n\n            this.log.info(\n                `Init done - found devices: online: ${this.hyperions.length - disconnected.length} - disconnected: ${disconnected.length} - configured: ${Array.isArray(this.adapter.config.devices) ? this.adapter.config.devices.length : 0} \n                - not configured: ${notConfigured.length}`,\n            );\n            if (this.hyperions.length === 0) {\n                this.log.warn('Init done - no devices found - please start at least one hyperion-server.');\n\n                this.log.warn('This adapter need at least 1 hyperion-server in config and/or online');\n                this.log.warn(\n                    'If you have a running hyperion-server and no devices are found, please check the network settings.',\n                );\n            }\n            if (this.initLogInterval) {\n                this.adapter.clearInterval(this.initLogInterval);\n            }\n        }, 5000);\n    }\n    async setOnline(): Promise<void> {\n        let connected = 0;\n        for (const hyperion of this.hyperions) {\n            connected += hyperion.connectionState === 'connected' ? 1 : 0;\n        }\n\n        this.library.writedp(`info.connection`, connected !== 0).catch(() => {\n            // nothing to do\n        });\n    }\n\n    /**\n     * findDevice - callback function\n     *\n     * @param protocol http or https\n     * @param ip ip address\n     * @param port port\n     * @param device device description\n     */\n    findDevice = async (protocol: string, ip: string, port: number, device: DescriptionType): Promise<void> => {\n        const data: configOfHyperionInstance = {\n            UDN: device.device.UDN.replace('uuid:', ''),\n            name: device.device.friendlyName,\n            protocol: protocol,\n            ip: ip,\n            port: port,\n            URLBase: device.URLBase,\n            token: '',\n            enabled: true,\n        };\n\n        if (this.hyperions.every(h => h.UDN !== data.UDN)) {\n            this.log.info(`Found new hyperion device: ${device.device.friendlyName}`);\n            const hyperion = new Hyperion(this.adapter, data.UDN, data);\n            this.hyperions.push(hyperion);\n            await hyperion.init();\n        }\n    };\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    onUnload(): void {\n        if (this.initLogInterval) {\n            this.adapter.clearInterval(this.initLogInterval);\n        }\n        for (const hyperion of this.hyperions) {\n            hyperion.onUnload();\n        }\n        this.network.onUnload();\n        //this.log.info('unload');\n    }\n\n    /**\n     * Is called if a subscribed state changes\n     * Only react on changes that are in a controls subfolder\n     * The state change is saved in the library\n     *\n     * @param id - The ID of the state that changed\n     * @param state - The new state value or null/undefined if the state was deleted\n     */\n    async onStateChange(id: string, state: ioBroker.State | null | undefined): Promise<void> {\n        if (state) {\n            const parts = id.split('.');\n            if (parts.length > 2 && parts[3] === 'controls') {\n                const tid = parts.slice(2).join('.');\n                this.library.setdb(tid, 'state', state.val, undefined, state.ack, state.ts);\n\n                const instance = parts[2];\n                const hyperion = this.hyperions.find(h => h.UDN === instance);\n                if (hyperion) {\n                    await hyperion.onStateChange(id, state);\n                }\n            }\n        }\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAAyB;AACzB,qBAAuD;AACvD,qBAAwB;AAOjB,MAAM,mBAAmB,yBAAU;AAAA,EACtC;AAAA,EACA,YAAwB,CAAC;AAAA,EACzB,aAAyC,CAAC;AAAA,EAE1C,kBAAiD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMjD,YAAY,SAAiC;AACzC,UAAM,SAAS,YAAY;AAC3B,SAAK,UAAU,IAAI,uBAAQ,KAAK,SAAS,SAAS;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,OAAsB;AACxB,UAAM,UAAU,KAAK,QAAQ,OAAO;AACpC,QAAI,SAAS;AACT,iBAAW,UAAU,SAAS;AAC1B,YAAI,OAAO,SAAS;AAChB,cAAI;AACA,gBAAI,KAAK,UAAU,MAAM,OAAK,EAAE,QAAQ,OAAO,GAAG,GAAG;AACjD,oBAAM,OAAiC;AAAA,gBACnC,KAAK,OAAO,IAAI,QAAQ,SAAS,EAAE;AAAA,gBACnC,MAAM,OAAO;AAAA,gBACb,UAAU,OAAO;AAAA,gBACjB,IAAI,OAAO;AAAA,gBACX,MAAM,OAAO;AAAA,gBACb,OAAO;AAAA,gBACP,SAAS;AAAA,cACb;AACA,mBAAK,IAAI,MAAM,gBAAgB,OAAO,IAAI,cAAc;AACxD,oBAAM,WAAW,IAAI,yBAAS,KAAK,SAAS,KAAK,KAAK,IAAI;AAC1D,mBAAK,UAAU,KAAK,QAAQ;AAC5B,oBAAM,SAAS,KAAK;AAAA,YACxB;AAAA,UACJ,SAAS,OAAO;AACZ,iBAAK,IAAI,KAAK,4BAA4B,OAAO,IAAI,MAAM,OAAO,KAAK,CAAC,EAAE;AAAA,UAC9E;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAEA,UAAM,KAAK,QAAQ,YAAY,KAAK,UAAU;AAC9C,SAAK,kBAAkB,KAAK,QAAQ,YAAY,MAAM;AAClD,UAAI,KAAK,UAAU,KAAK,OAAK,EAAE,oBAAoB,kBAAkB,GAAG;AACpE;AAAA,MACJ;AAEA,YAAM,gBACF,KAAK,UAAU;AAAA,QACX,UACI,EAAE,KAAK,QAAQ,OAAO,WAAW,CAAC,EAAE,KAAK,KAAK,CAAC,GAAG;AAAA,UAC9C,CAAC,MAAgC,EAAE,QAAQ,KAAK;AAAA,QACpD;AAAA,MACR,KAAK,CAAC;AAEV,YAAM,eACF,KAAK,UAAU;AAAA,QACX,UAAQ,KAAK,oBAAoB,kBAAkB,KAAK,oBAAoB;AAAA,MAChF,KAAK,CAAC;AAEV,WAAK,IAAI;AAAA,QACL,sCAAsC,KAAK,UAAU,SAAS,aAAa,MAAM,oBAAoB,aAAa,MAAM,kBAAkB,MAAM,QAAQ,KAAK,QAAQ,OAAO,OAAO,IAAI,KAAK,QAAQ,OAAO,QAAQ,SAAS,CAAC;AAAA,oCACzM,cAAc,MAAM;AAAA,MAC5C;AACA,UAAI,KAAK,UAAU,WAAW,GAAG;AAC7B,aAAK,IAAI,KAAK,2EAA2E;AAEzF,aAAK,IAAI,KAAK,sEAAsE;AACpF,aAAK,IAAI;AAAA,UACL;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,KAAK,iBAAiB;AACtB,aAAK,QAAQ,cAAc,KAAK,eAAe;AAAA,MACnD;AAAA,IACJ,GAAG,GAAI;AAAA,EACX;AAAA,EACA,MAAM,YAA2B;AAC7B,QAAI,YAAY;AAChB,eAAW,YAAY,KAAK,WAAW;AACnC,mBAAa,SAAS,oBAAoB,cAAc,IAAI;AAAA,IAChE;AAEA,SAAK,QAAQ,QAAQ,mBAAmB,cAAc,CAAC,EAAE,MAAM,MAAM;AAAA,IAErE,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,aAAa,OAAO,UAAkB,IAAY,MAAc,WAA2C;AACvG,UAAM,OAAiC;AAAA,MACnC,KAAK,OAAO,OAAO,IAAI,QAAQ,SAAS,EAAE;AAAA,MAC1C,MAAM,OAAO,OAAO;AAAA,MACpB;AAAA,MACA;AAAA,MACA;AAAA,MACA,SAAS,OAAO;AAAA,MAChB,OAAO;AAAA,MACP,SAAS;AAAA,IACb;AAEA,QAAI,KAAK,UAAU,MAAM,OAAK,EAAE,QAAQ,KAAK,GAAG,GAAG;AAC/C,WAAK,IAAI,KAAK,8BAA8B,OAAO,OAAO,YAAY,EAAE;AACxE,YAAM,WAAW,IAAI,yBAAS,KAAK,SAAS,KAAK,KAAK,IAAI;AAC1D,WAAK,UAAU,KAAK,QAAQ;AAC5B,YAAM,SAAS,KAAK;AAAA,IACxB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,WAAiB;AACb,QAAI,KAAK,iBAAiB;AACtB,WAAK,QAAQ,cAAc,KAAK,eAAe;AAAA,IACnD;AACA,eAAW,YAAY,KAAK,WAAW;AACnC,eAAS,SAAS;AAAA,IACtB;AACA,SAAK,QAAQ,SAAS;AAAA,EAE1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,cAAc,IAAY,OAAyD;AACrF,QAAI,OAAO;AACP,YAAM,QAAQ,GAAG,MAAM,GAAG;AAC1B,UAAI,MAAM,SAAS,KAAK,MAAM,CAAC,MAAM,YAAY;AAC7C,cAAM,MAAM,MAAM,MAAM,CAAC,EAAE,KAAK,GAAG;AACnC,aAAK,QAAQ,MAAM,KAAK,SAAS,MAAM,KAAK,QAAW,MAAM,KAAK,MAAM,EAAE;AAE1E,cAAM,WAAW,MAAM,CAAC;AACxB,cAAM,WAAW,KAAK,UAAU,KAAK,OAAK,EAAE,QAAQ,QAAQ;AAC5D,YAAI,UAAU;AACV,gBAAM,SAAS,cAAc,IAAI,KAAK;AAAA,QAC1C;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;",
  "names": []
}
